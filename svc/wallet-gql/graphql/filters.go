// Code generated by lab.weave.nl/weave/generator, DO NOT EDIT.

package graphql

import (
	"fmt"
	"strings"

	"github.com/lib/pq"
)

func (filter *BooleanFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *JSONFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Contains != nil {
		s := fmt.Sprintf("%s @> ?::jsonb", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Contains)
	}
	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.HasPath != nil {
		s := fmt.Sprintf("(%s #> ?::text[]) IS NOT NULL", fieldName)
		filterExpr = append(filterExpr, s)

		filterArgs = append(filterArgs, pq.Array(filter.HasPath))
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *PhoneNumberVerificationTypeFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.In != nil {
		s := fmt.Sprintf("%s = ANY(?::int[])", fieldName)
		filterExpr = append(filterExpr, s)

		filterArgs = append(filterArgs, pq.Array(filter.In))
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *StringFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.BeginsWith != nil {
		s := fmt.Sprintf("%s LIKE ? || '%%'", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.BeginsWith)
	}
	if filter.Contains != nil {
		s := fmt.Sprintf("%s LIKE '%%' || ? || '%%'", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Contains)
	}
	if filter.EndsWith != nil {
		s := fmt.Sprintf("%s LIKE '%%' || ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.EndsWith)
	}
	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.Ge != nil {
		s := fmt.Sprintf("%s >= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ge)
	}
	if filter.Gt != nil {
		s := fmt.Sprintf("%s > ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Gt)
	}
	if filter.Le != nil {
		s := fmt.Sprintf("%s <= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Le)
	}
	if filter.Lt != nil {
		s := fmt.Sprintf("%s < ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Lt)
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *TimeFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.Ge != nil {
		s := fmt.Sprintf("%s >= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ge)
	}
	if filter.Gt != nil {
		s := fmt.Sprintf("%s > ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Gt)
	}
	if filter.Le != nil {
		s := fmt.Sprintf("%s <= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Le)
	}
	if filter.Lt != nil {
		s := fmt.Sprintf("%s < ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Lt)
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *UUIDFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *ClientFilterInput) containsField(field string) bool {
	switch field {
	case "Color":
		if filter.Color != nil {
			return true
		}
	case "CreatedAt":
		if filter.CreatedAt != nil {
			return true
		}
	case "DeletedAt":
		if filter.DeletedAt != nil {
			return true
		}
	case "Unscoped":
		if filter.Unscoped != nil {
			return true
		}
	case "ExtClientID":
		if filter.ExtClientID != nil {
			return true
		}
	case "ID":
		if filter.ID != nil {
			return true
		}
	case "Icon":
		if filter.Icon != nil {
			return true
		}
	case "Logo":
		if filter.Logo != nil {
			return true
		}
	case "Name":
		if filter.Name != nil {
			return true
		}
	case "UpdatedAt":
		if filter.UpdatedAt != nil {
			return true
		}
	}

	if filter.Not != nil && filter.Not.containsField(field) {
		return true
	}

	for _, or := range filter.Or {
		if or.containsField(field) {
			return true
		}
	}

	for _, and := range filter.And {
		if and.containsField(field) {
			return true
		}
	}

	return false
}

func (filter *ClientFilterInput) parse() (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse()
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.Or != nil && len(filter.Or) > 0 {
		var subExpr []string
		for _, f := range filter.Or {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " OR "))
	}
	if filter.And != nil && len(filter.And) > 0 {
		var subExpr []string
		for _, f := range filter.And {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " AND "))
	}

	if filter.ID != nil {
		expr, args := filter.ID.parse("\"clients\".\"id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Color != nil {
		expr, args := filter.Color.parse("\"clients\".\"color\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.ExtClientID != nil {
		expr, args := filter.ExtClientID.parse("\"clients\".\"ext_client_id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Icon != nil {
		expr, args := filter.Icon.parse("\"clients\".\"icon\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Logo != nil {
		expr, args := filter.Logo.parse("\"clients\".\"logo\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Name != nil {
		expr, args := filter.Name.parse("\"clients\".\"name\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.CreatedAt != nil {
		expr, args := filter.CreatedAt.parse("\"clients\".\"created_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.DeletedAt != nil {
		expr, args := filter.DeletedAt.parse("\"clients\".\"deleted_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UpdatedAt != nil {
		expr, args := filter.UpdatedAt.parse("\"clients\".\"updated_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *ConsentFilterInput) containsField(field string) bool {
	switch field {
	case "AccessToken":
		if filter.AccessToken != nil {
			return true
		}
	case "ClientID":
		if filter.ClientID != nil {
			return true
		}
	case "CreatedAt":
		if filter.CreatedAt != nil {
			return true
		}
	case "DeletedAt":
		if filter.DeletedAt != nil {
			return true
		}
	case "Unscoped":
		if filter.Unscoped != nil {
			return true
		}
	case "Description":
		if filter.Description != nil {
			return true
		}
	case "Granted":
		if filter.Granted != nil {
			return true
		}
	case "ID":
		if filter.ID != nil {
			return true
		}
	case "Name":
		if filter.Name != nil {
			return true
		}
	case "Revoked":
		if filter.Revoked != nil {
			return true
		}
	case "Token":
		if filter.Token != nil {
			return true
		}
	case "UpdatedAt":
		if filter.UpdatedAt != nil {
			return true
		}
	case "UserID":
		if filter.UserID != nil {
			return true
		}
	}

	if filter.Not != nil && filter.Not.containsField(field) {
		return true
	}

	for _, or := range filter.Or {
		if or.containsField(field) {
			return true
		}
	}

	for _, and := range filter.And {
		if and.containsField(field) {
			return true
		}
	}

	return false
}

func (filter *ConsentFilterInput) parse() (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse()
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.Or != nil && len(filter.Or) > 0 {
		var subExpr []string
		for _, f := range filter.Or {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " OR "))
	}
	if filter.And != nil && len(filter.And) > 0 {
		var subExpr []string
		for _, f := range filter.And {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " AND "))
	}

	if filter.ID != nil {
		expr, args := filter.ID.parse("\"consents\".\"id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.AccessToken != nil {
		expr, args := filter.AccessToken.parse("\"consents\".\"access_token\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.ClientID != nil {
		expr, args := filter.ClientID.parse("\"consents\".\"client_id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Description != nil {
		expr, args := filter.Description.parse("\"consents\".\"description\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Granted != nil {
		expr, args := filter.Granted.parse("\"consents\".\"granted\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Name != nil {
		expr, args := filter.Name.parse("\"consents\".\"name\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Revoked != nil {
		expr, args := filter.Revoked.parse("\"consents\".\"revoked\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Token != nil {
		expr, args := filter.Token.parse("\"consents\".\"token\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UserID != nil {
		expr, args := filter.UserID.parse("\"consents\".\"user_id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.CreatedAt != nil {
		expr, args := filter.CreatedAt.parse("\"consents\".\"created_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.DeletedAt != nil {
		expr, args := filter.DeletedAt.parse("\"consents\".\"deleted_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UpdatedAt != nil {
		expr, args := filter.UpdatedAt.parse("\"consents\".\"updated_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *EmailAddressFilterInput) containsField(field string) bool {
	switch field {
	case "CreatedAt":
		if filter.CreatedAt != nil {
			return true
		}
	case "DeletedAt":
		if filter.DeletedAt != nil {
			return true
		}
	case "Unscoped":
		if filter.Unscoped != nil {
			return true
		}
	case "EmailAddress":
		if filter.EmailAddress != nil {
			return true
		}
	case "ID":
		if filter.ID != nil {
			return true
		}
	case "UpdatedAt":
		if filter.UpdatedAt != nil {
			return true
		}
	case "UserID":
		if filter.UserID != nil {
			return true
		}
	case "Verified":
		if filter.Verified != nil {
			return true
		}
	}

	if filter.Not != nil && filter.Not.containsField(field) {
		return true
	}

	for _, or := range filter.Or {
		if or.containsField(field) {
			return true
		}
	}

	for _, and := range filter.And {
		if and.containsField(field) {
			return true
		}
	}

	return false
}

func (filter *EmailAddressFilterInput) parse() (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse()
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.Or != nil && len(filter.Or) > 0 {
		var subExpr []string
		for _, f := range filter.Or {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " OR "))
	}
	if filter.And != nil && len(filter.And) > 0 {
		var subExpr []string
		for _, f := range filter.And {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " AND "))
	}

	if filter.ID != nil {
		expr, args := filter.ID.parse("\"email_addresses\".\"id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.EmailAddress != nil {
		expr, args := filter.EmailAddress.parse("\"email_addresses\".\"email_address\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UserID != nil {
		expr, args := filter.UserID.parse("\"email_addresses\".\"user_id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Verified != nil {
		expr, args := filter.Verified.parse("\"email_addresses\".\"verified\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.CreatedAt != nil {
		expr, args := filter.CreatedAt.parse("\"email_addresses\".\"created_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.DeletedAt != nil {
		expr, args := filter.DeletedAt.parse("\"email_addresses\".\"deleted_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UpdatedAt != nil {
		expr, args := filter.UpdatedAt.parse("\"email_addresses\".\"updated_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *PhoneNumberFilterInput) containsField(field string) bool {
	switch field {
	case "CreatedAt":
		if filter.CreatedAt != nil {
			return true
		}
	case "DeletedAt":
		if filter.DeletedAt != nil {
			return true
		}
	case "Unscoped":
		if filter.Unscoped != nil {
			return true
		}
	case "ID":
		if filter.ID != nil {
			return true
		}
	case "PhoneNumber":
		if filter.PhoneNumber != nil {
			return true
		}
	case "UpdatedAt":
		if filter.UpdatedAt != nil {
			return true
		}
	case "UserID":
		if filter.UserID != nil {
			return true
		}
	case "VerificationType":
		if filter.VerificationType != nil {
			return true
		}
	case "Verified":
		if filter.Verified != nil {
			return true
		}
	}

	if filter.Not != nil && filter.Not.containsField(field) {
		return true
	}

	for _, or := range filter.Or {
		if or.containsField(field) {
			return true
		}
	}

	for _, and := range filter.And {
		if and.containsField(field) {
			return true
		}
	}

	return false
}

func (filter *PhoneNumberFilterInput) parse() (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse()
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.Or != nil && len(filter.Or) > 0 {
		var subExpr []string
		for _, f := range filter.Or {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " OR "))
	}
	if filter.And != nil && len(filter.And) > 0 {
		var subExpr []string
		for _, f := range filter.And {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " AND "))
	}

	if filter.ID != nil {
		expr, args := filter.ID.parse("\"phone_numbers\".\"id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.PhoneNumber != nil {
		expr, args := filter.PhoneNumber.parse("\"phone_numbers\".\"phone_number\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UserID != nil {
		expr, args := filter.UserID.parse("\"phone_numbers\".\"user_id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.VerificationType != nil {
		expr, args := filter.VerificationType.parse("\"phone_numbers\".\"verification_type\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Verified != nil {
		expr, args := filter.Verified.parse("\"phone_numbers\".\"verified\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.CreatedAt != nil {
		expr, args := filter.CreatedAt.parse("\"phone_numbers\".\"created_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.DeletedAt != nil {
		expr, args := filter.DeletedAt.parse("\"phone_numbers\".\"deleted_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UpdatedAt != nil {
		expr, args := filter.UpdatedAt.parse("\"phone_numbers\".\"updated_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *UserFilterInput) containsField(field string) bool {
	switch field {
	case "Bsn":
		if filter.Bsn != nil {
			return true
		}
	case "CreatedAt":
		if filter.CreatedAt != nil {
			return true
		}
	case "DeletedAt":
		if filter.DeletedAt != nil {
			return true
		}
	case "Unscoped":
		if filter.Unscoped != nil {
			return true
		}
	case "Email":
		if filter.Email != nil {
			return true
		}
	case "ID":
		if filter.ID != nil {
			return true
		}
	case "Pseudonym":
		if filter.Pseudonym != nil {
			return true
		}
	case "Scopes":
		if filter.Scopes != nil {
			return true
		}
	case "UpdatedAt":
		if filter.UpdatedAt != nil {
			return true
		}
	}

	if filter.Not != nil && filter.Not.containsField(field) {
		return true
	}

	for _, or := range filter.Or {
		if or.containsField(field) {
			return true
		}
	}

	for _, and := range filter.And {
		if and.containsField(field) {
			return true
		}
	}

	return false
}

func (filter *UserFilterInput) parse() (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse()
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.Or != nil && len(filter.Or) > 0 {
		var subExpr []string
		for _, f := range filter.Or {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " OR "))
	}
	if filter.And != nil && len(filter.And) > 0 {
		var subExpr []string
		for _, f := range filter.And {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " AND "))
	}

	if filter.ID != nil {
		expr, args := filter.ID.parse("\"users\".\"id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Bsn != nil {
		expr, args := filter.Bsn.parse("\"users\".\"bsn\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Email != nil {
		expr, args := filter.Email.parse("\"users\".\"email\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Pseudonym != nil {
		expr, args := filter.Pseudonym.parse("\"users\".\"pseudonym\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Scopes != nil {
		expr, args := filter.Scopes.parse("\"users\".\"scopes\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.CreatedAt != nil {
		expr, args := filter.CreatedAt.parse("\"users\".\"created_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.DeletedAt != nil {
		expr, args := filter.DeletedAt.parse("\"users\".\"deleted_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UpdatedAt != nil {
		expr, args := filter.UpdatedAt.parse("\"users\".\"updated_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}
