// Code generated by lab.weave.nl/weave/generator, DO NOT EDIT.

package graphql

import (
	"context"
	"fmt"
	"strings"

	"github.com/99designs/gqlgen/graphql"
	"github.com/gofrs/uuid"
	"github.com/google/go-cmp/cmp"
	"github.com/jinzhu/gorm"
	"github.com/pkg/errors"
	"github.com/vektah/gqlparser/v2/ast"
	"golang.org/x/crypto/bcrypt"
	"github.com/nID-sourcecode/nid-core/svc/wallet-gql/auth"
	"github.com/nID-sourcecode/nid-core/svc/wallet-gql/models"
	generr "lab.weave.nl/weave/generator/pkg/errors"
	"lab.weave.nl/weave/generator/utils/database"
	"lab.weave.nl/weave/generator/utils/mutation"
	"lab.weave.nl/weave/generator/utils/sanitize"
	"lab.weave.nl/weave/generator/utils/sqlconv"
)

type userResolver struct {
	*Resolver
	Hooks *CustomUserHooks
}

var _ UserResolver = &userResolver{nil, nil}

type customUserHooks interface {
	MutatePassword(ctx context.Context, input string) (string, error)
}

type CustomUserHooks struct{ *Resolver }

var _ customUserHooks = &CustomUserHooks{nil}

func (r *mutationResolver) CreateUser(ctx context.Context, input CreateUser) (*models.User, error) {
	var err error
	var m models.User

	hasCreateAccess := false

	// Scope: 'api:admin', Relation: None
	if auth.UserHasScope(ctx, "api:admin") {
		if !input.containsField("DeletedAt") {
			hasCreateAccess = true
		}
	}

	if !hasCreateAccess {
		return nil, generr.ErrAccessDenied
	}

	err = database.Transact(r.Resolver.DB, func(tx *gorm.DB) error {
		if m, err = input.ToModel(ctx, r.Resolver); err != nil {
			return errors.Wrap(err, "converting input CreateUser to model")
		}
		create := tx.Create(&m)
		if err := create.Error; err != nil {
			return generr.WrapAsInternal(err, "creating User")
		}
		if err := create.First(&m).Error; err != nil {
			return generr.WrapAsInternal(err, "getting result from create of User")
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return &m, nil
}

func (r *mutationResolver) UpdateMe(ctx context.Context, input UpdateUser) (*models.User, error) {
	user := auth.GetUser(ctx)
	if user == nil {
		return nil, generr.ErrNotLoggedIn
	}
	return r.UpdateUser(ctx, user.ID, input)
}

func (r *mutationResolver) UpdateUser(ctx context.Context, id uuid.UUID, input UpdateUser) (*models.User, error) {
	var err error
	var m models.User
	fieldCtx := graphql.GetFieldContext(ctx)

	filters := []string{fmt.Sprintf("/*path: %v*/ /*fallback*/false", fieldCtx.Path())}
	var values []interface{}
	var restrictedFields []string

	// Scope: 'api:admin', Relation: None
	if auth.UserHasScope(ctx, "api:admin") {
		filters = append(filters, "/*api:admin None*/ true")
	}

	for _, f := range restrictedFields {
		if input.containsField(f) {
			return nil, fmt.Errorf("%w: %s", generr.ErrFieldAccessDenied, sanitize.GraphFieldName(f))
		}
	}

	err = database.Transact(r.Resolver.DB, func(tx *gorm.DB) error {
		m, err = input.ToModel(ctx, r.Resolver)
		if err != nil {
			return errors.Wrap(err, "converting input UpdateUser to model")
		}
		m.ID = id
		changes := mutation.ExtractChanges(ctx, m)
		update := tx.Model(&m).Where(strings.Join(filters, " OR "), values...).Updates(changes)
		if err := update.Error; err != nil {
			// FIXME check whether this can error on user error. If so, we should handle that elsewhere or somehow convert it here. https://lab.weave.nl/weave/generator/-/issues/105
			return generr.WrapAsInternal(err, fmt.Sprintf("updating User %v", m.ID))
		}
		if update.RowsAffected == 0 {
			return fmt.Errorf("%w (type=User,id=%v)", generr.ErrRecordNotFound, m.ID)
		}
		if err := update.First(&m).Error; err != nil {
			return generr.WrapAsInternal(err, "getting update result")
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return &m, nil
}

func (r *queryResolver) constructFilterUser(ctx context.Context, joins map[string]string) (filter string, values []interface{}, restrictedFields []string) {
	fieldCtx := graphql.GetFieldContext(ctx)
	filters := []string{fmt.Sprintf("/*path: %v*/ /*fallback*/false", fieldCtx.Path())}
	user := auth.GetUser(ctx)

	// Scope: 'api:access', Relation: IsMe, UserIDField: ID
	if auth.UserHasScope(ctx, "api:access") {
		filters = append(filters, "/*api:access IsMe*/ \"users\".\"id\" = ?")
		values = append(values, user.ID)
		restrictedFields = append(restrictedFields, "DeletedAt", "Unscoped")
	}

	return strings.Join(filters, " OR "), values, restrictedFields
}

func (r *queryResolver) readFilterUser(ctx context.Context, filter *UserFilterInput, joins map[string]string) (*gorm.DB, error) {
	db := r.Resolver.DB.Model(&models.User{})

	for _, v := range joins {
		db = db.Joins(v)
	}

	filters, values, restrictedFields := r.constructFilterUser(ctx, joins)
	db = db.Where(filters, values...)

	if filter != nil {
		for _, f := range restrictedFields {
			if filter.containsField(f) {
				return nil, fmt.Errorf("%w: %s", generr.ErrFieldAccessDenied, sanitize.GraphFieldName(f))
			}
		}
		expr, args := filter.parse()
		db = db.Where(expr, args...)
		if filter.Unscoped != nil && *filter.Unscoped {
			db = db.Unscoped()
		}
	}

	return db, nil
}

func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	user := auth.GetUser(ctx)
	if user == nil {
		return nil, generr.ErrNotLoggedIn
	}
	return r.User(ctx, user.ID)
}

func (r *queryResolver) User(ctx context.Context, id uuid.UUID) (*models.User, error) {
	m := models.User{}
	db, err := r.readFilterUser(ctx, nil, nil)
	if err != nil {
		return nil, err
	}
	err = db.Where(`"users"."id" = ?`, id).First(&m).Error
	if err != nil {
		if gorm.IsRecordNotFoundError(err) {
			return nil, generr.ErrRecordNotFound
		}
		return nil, generr.WrapAsInternal(err, fmt.Sprintf("getting Userrecord with id %s from db", id))
	}
	return &m, nil
}

func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int, filter *UserFilterInput, orderBy *string, order UserFieldName, orderDirection OrderDirection) ([]*models.User, error) {
	var m []*models.User
	db, err := r.readFilterUser(ctx, filter, nil)
	if err != nil {
		return nil, err
	}

	orderString, err := sqlconv.ParseOrderBy(ctx, orderBy, &order, &orderDirection)
	if err != nil {
		return nil, generr.WrapAsInternal(err, "parsing order by")
	}

	err = db.Limit(*limit).Offset(*offset).Order(orderString).Find(&m).Error
	if err != nil {
		return nil, generr.WrapAsInternal(err, "getting Users from db")
	}
	return m, nil
}

func (r *userResolver) Consents(ctx context.Context, obj *models.User, limit *int, offset *int, filter *ConsentFilterInput, orderBy *string, order ConsentFieldName, orderDirection OrderDirection) ([]*models.Consent, error) {
	if filter == nil {
		filter = &ConsentFilterInput{}
	}
	if filter.And == nil {
		filter.And = []*ConsentFilterInput{}
	}
	filter.And = append(filter.And, &ConsentFilterInput{
		UserID: &UUIDFilterInput{Eq: &obj.ID},
	})
	return r.Query().Consents(ctx, limit, offset, filter, orderBy, order, orderDirection)
}

func (r *userResolver) EmailAddresses(ctx context.Context, obj *models.User, limit *int, offset *int, filter *EmailAddressFilterInput, orderBy *string, order EmailAddressFieldName, orderDirection OrderDirection) ([]*models.EmailAddress, error) {
	if filter == nil {
		filter = &EmailAddressFilterInput{}
	}
	if filter.And == nil {
		filter.And = []*EmailAddressFilterInput{}
	}
	filter.And = append(filter.And, &EmailAddressFilterInput{
		UserID: &UUIDFilterInput{Eq: &obj.ID},
	})
	return r.Query().EmailAddresses(ctx, limit, offset, filter, orderBy, order, orderDirection)
}

func (r *userResolver) ID(ctx context.Context, obj *models.User) (uuid.UUID, error) {
	return obj.ID, nil
}

func (r *userResolver) PhoneNumbers(ctx context.Context, obj *models.User, limit *int, offset *int, filter *PhoneNumberFilterInput, orderBy *string, order PhoneNumberFieldName, orderDirection OrderDirection) ([]*models.PhoneNumber, error) {
	if filter == nil {
		filter = &PhoneNumberFilterInput{}
	}
	if filter.And == nil {
		filter.And = []*PhoneNumberFilterInput{}
	}
	filter.And = append(filter.And, &PhoneNumberFilterInput{
		UserID: &UUIDFilterInput{Eq: &obj.ID},
	})
	return r.Query().PhoneNumbers(ctx, limit, offset, filter, orderBy, order, orderDirection)
}

var _ Directive = &userResolver{nil, nil}

func (r *userResolver) HasFieldAccess(ctx context.Context, obj interface{}, next graphql.Resolver) (interface{}, error) {
	model := castUser(obj)
	if model == nil {
		return nil, generr.ErrAccessDenied
	}
	fieldName := graphql.GetFieldContext(ctx).Field.Name
	if path, ok := graphql.GetFieldContext(ctx).Path()[0].(ast.PathName); ok && path == "createUser" {
		ctx = auth.SetUser(ctx, model)
	}
	user := auth.GetUser(ctx)

	// Scope: 'api:access', Relation: IsMe, UserIDField: ID
	if auth.UserHasScope(ctx, "api:access") && cmp.Equal(&model.ID, &user.ID) {
		if map[string]bool{
			"bsn":            true,
			"consents":       true,
			"createdAt":      true,
			"devices":        true,
			"email":          true,
			"emailAddresses": true,
			"id":             true,
			"password":       true,
			"phoneNumbers":   true,
			"pseudonym":      true,
			"scopes":         true,
			"updatedAt":      true,
		}[fieldName] {
			return next(ctx)
		}
	}

	return nil, generr.ErrAccessDenied
}

func (h *CustomUserHooks) MutatePassword(ctx context.Context, input string) (string, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input), bcrypt.DefaultCost)
	if err != nil {
		return "", generr.WrapAsInternal(err, "hashing password")
	}
	return string(hashedPassword), nil
}

func castUser(obj interface{}) *models.User {
	switch res := obj.(type) {
	case **models.User:
		return *res
	case *models.User:
		return res
	case models.User:
		return &res
	default:
		return nil
	}
}
