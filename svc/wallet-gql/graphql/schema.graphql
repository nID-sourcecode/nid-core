# Code generated by lab.weave.nl/weave/generator, DO NOT EDIT.

scalar JSON
scalar Time
scalar UUID

enum OrderDirection {
  ASC
  DESC
}

schema {
  query: Query
  mutation: Mutation
}

type Query {
  me: User!

  client(id: UUID!): Client!
  clients(limit: Int = 100, offset: Int = -1, filter: ClientFilterInput, orderBy: String @deprecated(reason: "use order instead"), order: ClientFieldName! = CREATED_AT, orderDirection: OrderDirection! = ASC): [Client!]!

  consent(id: UUID!): Consent!
  consents(limit: Int = 100, offset: Int = -1, filter: ConsentFilterInput, orderBy: String @deprecated(reason: "use order instead"), order: ConsentFieldName! = CREATED_AT, orderDirection: OrderDirection! = ASC): [Consent!]!

  emailAddress(id: UUID!): EmailAddress!
  emailAddresses(limit: Int = 100, offset: Int = -1, filter: EmailAddressFilterInput, orderBy: String @deprecated(reason: "use order instead"), order: EmailAddressFieldName! = CREATED_AT, orderDirection: OrderDirection! = ASC): [EmailAddress!]!

  phoneNumber(id: UUID!): PhoneNumber!
  phoneNumbers(limit: Int = 100, offset: Int = -1, filter: PhoneNumberFilterInput, orderBy: String @deprecated(reason: "use order instead"), order: PhoneNumberFieldName! = CREATED_AT, orderDirection: OrderDirection! = ASC): [PhoneNumber!]!

  user(id: UUID!): User!
  users(limit: Int = 100, offset: Int = -1, filter: UserFilterInput, orderBy: String @deprecated(reason: "use order instead"), order: UserFieldName! = CREATED_AT, orderDirection: OrderDirection! = ASC): [User!]!
}

type Mutation {
  createJwt(email: String!, password: String!): String!
  refreshJwt(token: String!): String!
  updateMe(input: UpdateUser!): User!

  # Client Mutations
  createClient(input: CreateClient!): Client!
  updateClient(id: UUID!, input: UpdateClient!): Client!

  # EmailAddress Mutations
  createEmailAddress(input: CreateEmailAddress!): EmailAddress!
  updateEmailAddress(id: UUID!, input: UpdateEmailAddress!): EmailAddress!

  # PhoneNumber Mutations
  createPhoneNumber(input: CreatePhoneNumber!): PhoneNumber!
  updatePhoneNumber(id: UUID!, input: UpdatePhoneNumber!): PhoneNumber!

  # RevokeConsent Mutations
  createRevokeConsent(input: CreateRevokeConsent!): RevokeConsent!

  # User Mutations
  createUser(input: CreateUser!): User!
  updateUser(id: UUID!, input: UpdateUser!): User!
}

enum PhoneNumberVerificationType {
  SMS
  TTS
}

directive @hasClientAccess on FIELD_DEFINITION

type Client {
  id: UUID! @hasClientAccess                          # primary key
  color: String! @hasClientAccess
  consents(limit: Int = 100, offset: Int = -1, filter: ConsentFilterInput, orderBy: String = "createdAt", order: ConsentFieldName! = CREATED_AT, orderDirection: OrderDirection! = ASC): [Consent!]! @hasClientAccess
  extClientId: String! @hasClientAccess
  icon: String! @hasClientAccess
  logo: String! @hasClientAccess
  name: String! @hasClientAccess
  createdAt: Time! @hasClientAccess
  deletedAt: Time @hasClientAccess
  updatedAt: Time! @hasClientAccess
}

input CreateClient {
  color: String!
  extClientId: String!
  icon: String!
  logo: String!
  name: String!
}

input UpdateClient {
  color: String
  extClientId: String
  icon: String
  logo: String
  name: String
}

enum ClientFieldName {
  ID
  COLOR
  EXT_CLIENT_ID
  ICON
  LOGO
  NAME
  CREATED_AT
  DELETED_AT
  UPDATED_AT
}

directive @hasConsentAccess on FIELD_DEFINITION

type Consent {
  id: UUID! @hasConsentAccess                         # primary key
  accessToken: String! @hasConsentAccess
  client: Client! @hasConsentAccess
  clientId: UUID! @hasConsentAccess
  description: String! @hasConsentAccess
  granted: Time @hasConsentAccess
  name: String! @hasConsentAccess
  revoked: Time @hasConsentAccess
  token: JSON! @hasConsentAccess
  user: User! @hasConsentAccess
  userId: UUID! @hasConsentAccess
  createdAt: Time! @hasConsentAccess
  deletedAt: Time @hasConsentAccess
  updatedAt: Time! @hasConsentAccess
}

enum ConsentFieldName {
  ID
  ACCESS_TOKEN
  CLIENT_ID
  DESCRIPTION
  GRANTED
  NAME
  REVOKED
  TOKEN
  USER_ID
  CREATED_AT
  DELETED_AT
  UPDATED_AT
}

directive @hasEmailAddressAccess on FIELD_DEFINITION

type EmailAddress {
  id: UUID! @hasEmailAddressAccess                    # primary key
  emailAddress: String! @hasEmailAddressAccess
  user: User! @hasEmailAddressAccess
  userId: UUID! @hasEmailAddressAccess
  verified: Boolean! @hasEmailAddressAccess
  createdAt: Time! @hasEmailAddressAccess
  deletedAt: Time @hasEmailAddressAccess
  updatedAt: Time! @hasEmailAddressAccess
}

input CreateEmailAddress {
  emailAddress: String!
  userId: UUID
}

input UpdateEmailAddress {
  emailAddress: String
  userId: UUID
}

enum EmailAddressFieldName {
  ID
  EMAIL_ADDRESS
  USER_ID
  VERIFICATION_TOKEN
  VERIFIED
  CREATED_AT
  DELETED_AT
  UPDATED_AT
}

directive @hasPhoneNumberAccess on FIELD_DEFINITION

type PhoneNumber {
  id: UUID! @hasPhoneNumberAccess                     # primary key
  phoneNumber: String! @hasPhoneNumberAccess
  user: User! @hasPhoneNumberAccess
  userId: UUID! @hasPhoneNumberAccess
  verificationType: PhoneNumberVerificationType! @hasPhoneNumberAccess
  verified: Boolean! @hasPhoneNumberAccess
  createdAt: Time! @hasPhoneNumberAccess
  deletedAt: Time @hasPhoneNumberAccess
  updatedAt: Time! @hasPhoneNumberAccess
}

input CreatePhoneNumber {
  phoneNumber: String!
  userId: UUID
  verificationType: PhoneNumberVerificationType!
}

input UpdatePhoneNumber {
  phoneNumber: String
  userId: UUID
  verificationType: PhoneNumberVerificationType
}

enum PhoneNumberFieldName {
  ID
  PHONE_NUMBER
  USER_ID
  VERIFICATION_TOKEN
  VERIFICATION_TYPE
  VERIFIED
  CREATED_AT
  DELETED_AT
  UPDATED_AT
}

type RevokeConsent {
  id: UUID!
  revoked: Time!
}

input CreateRevokeConsent {
  id: UUID
}

enum RevokeConsentFieldName {
  ID
  REVOKED
}

directive @hasUserAccess on FIELD_DEFINITION

type User {
  id: UUID! @hasUserAccess                            # primary key
  bsn: String! @hasUserAccess                         # unique index: "bsn"
  consents(limit: Int = 100, offset: Int = -1, filter: ConsentFilterInput, orderBy: String = "createdAt", order: ConsentFieldName! = CREATED_AT, orderDirection: OrderDirection! = ASC): [Consent!]! @hasUserAccess
  email: String! @hasUserAccess
  emailAddresses(limit: Int = 100, offset: Int = -1, filter: EmailAddressFilterInput, orderBy: String = "createdAt", order: EmailAddressFieldName! = CREATED_AT, orderDirection: OrderDirection! = ASC): [EmailAddress!]! @hasUserAccess
  phoneNumbers(limit: Int = 100, offset: Int = -1, filter: PhoneNumberFilterInput, orderBy: String = "createdAt", order: PhoneNumberFieldName! = CREATED_AT, orderDirection: OrderDirection! = ASC): [PhoneNumber!]! @hasUserAccess
  pseudonym: String! @hasUserAccess                   # unique index: "pseudonym"
  scopes: JSON! @hasUserAccess
  createdAt: Time! @hasUserAccess
  deletedAt: Time @hasUserAccess
  updatedAt: Time! @hasUserAccess
}

input CreateUser {
  bsn: String!                                        # unique index: "bsn"
  email: String!
  password: String!
  pseudonym: String!                                  # unique index: "pseudonym"
  scopes: JSON
}

input UpdateUser {
  bsn: String                                         # unique index: "bsn"
  email: String
  password: String
  pseudonym: String                                   # unique index: "pseudonym"
  scopes: JSON
}

enum UserFieldName {
  ID
  BSN
  EMAIL
  PASSWORD
  PSEUDONYM
  SCOPES
  CREATED_AT
  DELETED_AT
  UPDATED_AT
}

input ClientFilterInput {
  id: UUIDFilterInput
  color: StringFilterInput
  extClientId: StringFilterInput
  icon: StringFilterInput
  logo: StringFilterInput
  name: StringFilterInput
  createdAt: TimeFilterInput
  deletedAt: TimeFilterInput
  updatedAt: TimeFilterInput
  unscoped: Boolean

  not: ClientFilterInput
  or: [ClientFilterInput!]
  and: [ClientFilterInput!]
}

input ConsentFilterInput {
  id: UUIDFilterInput
  accessToken: StringFilterInput
  clientId: UUIDFilterInput
  description: StringFilterInput
  granted: TimeFilterInput
  name: StringFilterInput
  revoked: TimeFilterInput
  token: JSONFilterInput
  userId: UUIDFilterInput
  createdAt: TimeFilterInput
  deletedAt: TimeFilterInput
  updatedAt: TimeFilterInput
  unscoped: Boolean

  not: ConsentFilterInput
  or: [ConsentFilterInput!]
  and: [ConsentFilterInput!]
}

input EmailAddressFilterInput {
  id: UUIDFilterInput
  emailAddress: StringFilterInput
  userId: UUIDFilterInput
  verified: BooleanFilterInput
  createdAt: TimeFilterInput
  deletedAt: TimeFilterInput
  updatedAt: TimeFilterInput
  unscoped: Boolean

  not: EmailAddressFilterInput
  or: [EmailAddressFilterInput!]
  and: [EmailAddressFilterInput!]
}

input PhoneNumberFilterInput {
  id: UUIDFilterInput
  phoneNumber: StringFilterInput
  userId: UUIDFilterInput
  verificationType: PhoneNumberVerificationTypeFilterInput
  verified: BooleanFilterInput
  createdAt: TimeFilterInput
  deletedAt: TimeFilterInput
  updatedAt: TimeFilterInput
  unscoped: Boolean

  not: PhoneNumberFilterInput
  or: [PhoneNumberFilterInput!]
  and: [PhoneNumberFilterInput!]
}

input UserFilterInput {
  id: UUIDFilterInput
  bsn: StringFilterInput
  email: StringFilterInput
  pseudonym: StringFilterInput
  scopes: JSONFilterInput
  createdAt: TimeFilterInput
  deletedAt: TimeFilterInput
  updatedAt: TimeFilterInput
  unscoped: Boolean

  not: UserFilterInput
  or: [UserFilterInput!]
  and: [UserFilterInput!]
}

input BooleanFilterInput {
  eq: Boolean
  ne: Boolean

  isSet: Boolean
  not: BooleanFilterInput
}

input JSONFilterInput {
  contains: JSON
  eq: JSON
  hasPath: [String!]
  ne: JSON

  isSet: Boolean
  not: JSONFilterInput
}

input PhoneNumberVerificationTypeFilterInput {
  eq: PhoneNumberVerificationType
  in: [PhoneNumberVerificationType!]
  ne: PhoneNumberVerificationType

  isSet: Boolean
  not: PhoneNumberVerificationTypeFilterInput
}

input StringFilterInput {
  beginsWith: String
  contains: String
  endsWith: String
  eq: String
  ge: String
  gt: String
  le: String
  lt: String
  ne: String

  isSet: Boolean
  not: StringFilterInput
}

input TimeFilterInput {
  eq: Time
  ge: Time
  gt: Time
  le: Time
  lt: Time
  ne: Time

  isSet: Boolean
  not: TimeFilterInput
}

input UUIDFilterInput {
  eq: UUID
  ne: UUID

  isSet: Boolean
  not: UUIDFilterInput
}

