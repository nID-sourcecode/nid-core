// Code generated by lab.weave.nl/weave/generator, DO NOT EDIT.

package graphql

import (
	"fmt"
	"strings"

	"github.com/lib/pq"
)

func (filter *ScriptStatusFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.In != nil {
		s := fmt.Sprintf("%s = ANY(?::int[])", fieldName)
		filterExpr = append(filterExpr, s)

		filterArgs = append(filterArgs, pq.Array(filter.In))
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *StringFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.BeginsWith != nil {
		s := fmt.Sprintf("%s LIKE ? || '%%'", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.BeginsWith)
	}
	if filter.Contains != nil {
		s := fmt.Sprintf("%s LIKE '%%' || ? || '%%'", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Contains)
	}
	if filter.EndsWith != nil {
		s := fmt.Sprintf("%s LIKE '%%' || ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.EndsWith)
	}
	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.Ge != nil {
		s := fmt.Sprintf("%s >= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ge)
	}
	if filter.Gt != nil {
		s := fmt.Sprintf("%s > ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Gt)
	}
	if filter.Le != nil {
		s := fmt.Sprintf("%s <= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Le)
	}
	if filter.Lt != nil {
		s := fmt.Sprintf("%s < ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Lt)
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *TimeFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.Ge != nil {
		s := fmt.Sprintf("%s >= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ge)
	}
	if filter.Gt != nil {
		s := fmt.Sprintf("%s > ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Gt)
	}
	if filter.Le != nil {
		s := fmt.Sprintf("%s <= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Le)
	}
	if filter.Lt != nil {
		s := fmt.Sprintf("%s < ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Lt)
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *UUIDFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *ScriptFilterInput) containsField(field string) bool {
	switch field {
	case "CreatedAt":
		if filter.CreatedAt != nil {
			return true
		}
	case "DeletedAt":
		if filter.DeletedAt != nil {
			return true
		}
	case "Unscoped":
		if filter.Unscoped != nil {
			return true
		}
	case "Description":
		if filter.Description != nil {
			return true
		}
	case "ID":
		if filter.ID != nil {
			return true
		}
	case "Name":
		if filter.Name != nil {
			return true
		}
	case "Status":
		if filter.Status != nil {
			return true
		}
	case "UpdatedAt":
		if filter.UpdatedAt != nil {
			return true
		}
	}

	if filter.Not != nil && filter.Not.containsField(field) {
		return true
	}

	for _, or := range filter.Or {
		if or.containsField(field) {
			return true
		}
	}

	for _, and := range filter.And {
		if and.containsField(field) {
			return true
		}
	}

	return false
}

func (filter *ScriptFilterInput) parse() (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse()
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.Or != nil && len(filter.Or) > 0 {
		var subExpr []string
		for _, f := range filter.Or {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " OR "))
	}
	if filter.And != nil && len(filter.And) > 0 {
		var subExpr []string
		for _, f := range filter.And {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " AND "))
	}

	if filter.ID != nil {
		expr, args := filter.ID.parse("\"scripts\".\"id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Description != nil {
		expr, args := filter.Description.parse("\"scripts\".\"description\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Name != nil {
		expr, args := filter.Name.parse("\"scripts\".\"name\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Status != nil {
		expr, args := filter.Status.parse("\"scripts\".\"status\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.CreatedAt != nil {
		expr, args := filter.CreatedAt.parse("\"scripts\".\"created_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.DeletedAt != nil {
		expr, args := filter.DeletedAt.parse("\"scripts\".\"deleted_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UpdatedAt != nil {
		expr, args := filter.UpdatedAt.parse("\"scripts\".\"updated_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *ScriptSourceFilterInput) containsField(field string) bool {
	switch field {
	case "ChangeDescription":
		if filter.ChangeDescription != nil {
			return true
		}
	case "Checksum":
		if filter.Checksum != nil {
			return true
		}
	case "CreatedAt":
		if filter.CreatedAt != nil {
			return true
		}
	case "DeletedAt":
		if filter.DeletedAt != nil {
			return true
		}
	case "Unscoped":
		if filter.Unscoped != nil {
			return true
		}
	case "ID":
		if filter.ID != nil {
			return true
		}
	case "RawScript":
		if filter.RawScript != nil {
			return true
		}
	case "ScriptID":
		if filter.ScriptID != nil {
			return true
		}
	case "SignedURL":
		if filter.SignedURL != nil {
			return true
		}
	case "UpdatedAt":
		if filter.UpdatedAt != nil {
			return true
		}
	case "Version":
		if filter.Version != nil {
			return true
		}
	}

	if filter.Not != nil && filter.Not.containsField(field) {
		return true
	}

	for _, or := range filter.Or {
		if or.containsField(field) {
			return true
		}
	}

	for _, and := range filter.And {
		if and.containsField(field) {
			return true
		}
	}

	return false
}

func (filter *ScriptSourceFilterInput) parse() (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse()
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.Or != nil && len(filter.Or) > 0 {
		var subExpr []string
		for _, f := range filter.Or {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " OR "))
	}
	if filter.And != nil && len(filter.And) > 0 {
		var subExpr []string
		for _, f := range filter.And {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " AND "))
	}

	if filter.ID != nil {
		expr, args := filter.ID.parse("\"script_sources\".\"id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.ChangeDescription != nil {
		expr, args := filter.ChangeDescription.parse("\"script_sources\".\"change_description\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Checksum != nil {
		expr, args := filter.Checksum.parse("\"script_sources\".\"checksum\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.RawScript != nil {
		expr, args := filter.RawScript.parse("\"script_sources\".\"raw_script\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.ScriptID != nil {
		expr, args := filter.ScriptID.parse("\"script_sources\".\"script_id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.SignedURL != nil {
		expr, args := filter.SignedURL.parse("\"script_sources\".\"signed_url\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Version != nil {
		expr, args := filter.Version.parse("\"script_sources\".\"version\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.CreatedAt != nil {
		expr, args := filter.CreatedAt.parse("\"script_sources\".\"created_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.DeletedAt != nil {
		expr, args := filter.DeletedAt.parse("\"script_sources\".\"deleted_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UpdatedAt != nil {
		expr, args := filter.UpdatedAt.parse("\"script_sources\".\"updated_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}
