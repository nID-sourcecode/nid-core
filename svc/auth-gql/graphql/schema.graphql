# Code generated by lab.weave.nl/weave/generator, DO NOT EDIT.

scalar JSON
scalar Time
scalar UUID

enum OrderDirection {
  ASC
  DESC
}

schema {
  query: Query
  mutation: Mutation
}

type Query {
  client(id: UUID!): Client!
  clients(limit: Int = 100, offset: Int = -1, filter: ClientFilterInput, orderBy: String @deprecated(reason: "use order instead"), order: ClientFieldName! = CREATED_AT, orderDirection: OrderDirection! = ASC): [Client!]!
}

type Mutation {
  createJwt(email: String!, password: String!): String!
  refreshJwt(token: String!): String!
}

enum AccessModelType {
  GQL
  REST
}

enum SessionState {
  UNCLAIMED
  CLAIMED
  ACCEPTED
  REJECTED
  CODE_GRANTED
  TOKEN_GRANTED
}

directive @hasClientAccess on FIELD_DEFINITION

type Client {
  id: UUID! @hasClientAccess                          # primary key
  color: String! @hasClientAccess
  icon: String! @hasClientAccess
  logo: String! @hasClientAccess
  metadata: JSON! @hasClientAccess
  name: String! @hasClientAccess
  createdAt: Time! @hasClientAccess
  deletedAt: Time @hasClientAccess
  updatedAt: Time! @hasClientAccess
}

enum ClientFieldName {
  ID
  COLOR
  ICON
  LOGO
  METADATA
  NAME
  PASSWORD
  CREATED_AT
  DELETED_AT
  UPDATED_AT
}

input ClientFilterInput {
  id: UUIDFilterInput
  color: StringFilterInput
  icon: StringFilterInput
  logo: StringFilterInput
  metadata: JSONFilterInput
  name: StringFilterInput
  createdAt: TimeFilterInput
  deletedAt: TimeFilterInput
  updatedAt: TimeFilterInput
  unscoped: Boolean

  not: ClientFilterInput
  or: [ClientFilterInput!]
  and: [ClientFilterInput!]
}

input AccessModelTypeFilterInput {
  eq: AccessModelType
  in: [AccessModelType!]
  ne: AccessModelType

  isSet: Boolean
  not: AccessModelTypeFilterInput
}

input JSONFilterInput {
  contains: JSON
  eq: JSON
  hasPath: [String!]
  ne: JSON

  isSet: Boolean
  not: JSONFilterInput
}

input SessionStateFilterInput {
  eq: SessionState
  in: [SessionState!]
  ne: SessionState

  isSet: Boolean
  not: SessionStateFilterInput
}

input StringFilterInput {
  beginsWith: String
  contains: String
  endsWith: String
  eq: String
  ge: String
  gt: String
  le: String
  lt: String
  ne: String

  isSet: Boolean
  not: StringFilterInput
}

input TimeFilterInput {
  eq: Time
  ge: Time
  gt: Time
  le: Time
  lt: Time
  ne: Time

  isSet: Boolean
  not: TimeFilterInput
}

input UUIDFilterInput {
  eq: UUID
  ne: UUID

  isSet: Boolean
  not: UUIDFilterInput
}

