// Code generated by lab.weave.nl/weave/generator, DO NOT EDIT.

package graphql

import (
	"fmt"
	"strings"

	"github.com/lib/pq"
)

func (filter *AccessModelTypeFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.In != nil {
		s := fmt.Sprintf("%s = ANY(?::int[])", fieldName)
		filterExpr = append(filterExpr, s)

		filterArgs = append(filterArgs, pq.Array(filter.In))
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *JSONFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Contains != nil {
		s := fmt.Sprintf("%s @> ?::jsonb", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Contains)
	}
	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.HasPath != nil {
		s := fmt.Sprintf("(%s #> ?::text[]) IS NOT NULL", fieldName)
		filterExpr = append(filterExpr, s)

		filterArgs = append(filterArgs, pq.Array(filter.HasPath))
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *SessionStateFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.In != nil {
		s := fmt.Sprintf("%s = ANY(?::int[])", fieldName)
		filterExpr = append(filterExpr, s)

		filterArgs = append(filterArgs, pq.Array(filter.In))
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *StringFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.BeginsWith != nil {
		s := fmt.Sprintf("%s LIKE ? || '%%'", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.BeginsWith)
	}
	if filter.Contains != nil {
		s := fmt.Sprintf("%s LIKE '%%' || ? || '%%'", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Contains)
	}
	if filter.EndsWith != nil {
		s := fmt.Sprintf("%s LIKE '%%' || ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.EndsWith)
	}
	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.Ge != nil {
		s := fmt.Sprintf("%s >= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ge)
	}
	if filter.Gt != nil {
		s := fmt.Sprintf("%s > ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Gt)
	}
	if filter.Le != nil {
		s := fmt.Sprintf("%s <= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Le)
	}
	if filter.Lt != nil {
		s := fmt.Sprintf("%s < ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Lt)
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *TimeFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.Ge != nil {
		s := fmt.Sprintf("%s >= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ge)
	}
	if filter.Gt != nil {
		s := fmt.Sprintf("%s > ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Gt)
	}
	if filter.Le != nil {
		s := fmt.Sprintf("%s <= ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Le)
	}
	if filter.Lt != nil {
		s := fmt.Sprintf("%s < ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Lt)
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *UUIDFilterInput) parse(fieldName string) (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse(fieldName)
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.IsSet != nil {
		if *filter.IsSet {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NOT NULL", fieldName))
		} else {
			filterExpr = append(filterExpr, fmt.Sprintf("%s IS NULL", fieldName))
		}
	}

	if filter.Eq != nil {
		s := fmt.Sprintf("%s = ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Eq)
	}
	if filter.Ne != nil {
		s := fmt.Sprintf("%s != ?", fieldName)
		filterExpr = append(filterExpr, s)
		filterArgs = append(filterArgs, filter.Ne)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}

func (filter *ClientFilterInput) containsField(field string) bool {
	switch field {
	case "Color":
		if filter.Color != nil {
			return true
		}
	case "CreatedAt":
		if filter.CreatedAt != nil {
			return true
		}
	case "DeletedAt":
		if filter.DeletedAt != nil {
			return true
		}
	case "Unscoped":
		if filter.Unscoped != nil {
			return true
		}
	case "ID":
		if filter.ID != nil {
			return true
		}
	case "Icon":
		if filter.Icon != nil {
			return true
		}
	case "Logo":
		if filter.Logo != nil {
			return true
		}
	case "Metadata":
		if filter.Metadata != nil {
			return true
		}
	case "Name":
		if filter.Name != nil {
			return true
		}
	case "UpdatedAt":
		if filter.UpdatedAt != nil {
			return true
		}
	}

	if filter.Not != nil && filter.Not.containsField(field) {
		return true
	}

	for _, or := range filter.Or {
		if or.containsField(field) {
			return true
		}
	}

	for _, and := range filter.And {
		if and.containsField(field) {
			return true
		}
	}

	return false
}

func (filter *ClientFilterInput) parse() (string, []interface{}) {
	var filterExpr []string
	var filterArgs []interface{}
	if filter.Not != nil {
		expr, args := filter.Not.parse()
		filterExpr = append(filterExpr, fmt.Sprintf("NOT (%s)", expr))
		filterArgs = append(filterArgs, args...)
	}
	if filter.Or != nil && len(filter.Or) > 0 {
		var subExpr []string
		for _, f := range filter.Or {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " OR "))
	}
	if filter.And != nil && len(filter.And) > 0 {
		var subExpr []string
		for _, f := range filter.And {
			expr, args := f.parse()
			subExpr = append(subExpr, expr)
			filterArgs = append(filterArgs, args...)
		}
		filterExpr = append(filterExpr, strings.Join(subExpr, " AND "))
	}

	if filter.ID != nil {
		expr, args := filter.ID.parse("\"clients\".\"id\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Color != nil {
		expr, args := filter.Color.parse("\"clients\".\"color\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Icon != nil {
		expr, args := filter.Icon.parse("\"clients\".\"icon\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Logo != nil {
		expr, args := filter.Logo.parse("\"clients\".\"logo\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Metadata != nil {
		expr, args := filter.Metadata.parse("\"clients\".\"metadata\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.Name != nil {
		expr, args := filter.Name.parse("\"clients\".\"name\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.CreatedAt != nil {
		expr, args := filter.CreatedAt.parse("\"clients\".\"created_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.DeletedAt != nil {
		expr, args := filter.DeletedAt.parse("\"clients\".\"deleted_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}
	if filter.UpdatedAt != nil {
		expr, args := filter.UpdatedAt.parse("\"clients\".\"updated_at\"")
		filterExpr = append(filterExpr, expr)
		filterArgs = append(filterArgs, args...)
	}

	if len(filterExpr) == 1 {
		return filterExpr[0], filterArgs
	}
	if len(filterExpr) > 0 {
		res := strings.Join(filterExpr, ") AND (")
		return "(" + res + ")", filterArgs
	}
	return "", filterArgs
}
