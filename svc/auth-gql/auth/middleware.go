// Code generated by lab.weave.nl/weave/generator, DO NOT EDIT.

package auth

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/99designs/gqlgen/graphql"
	"github.com/dgrijalva/jwt-go"
	"github.com/jinzhu/gorm"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"golang.org/x/crypto/bcrypt"
	"lab.weave.nl/nid/nid-core/svc/auth/models"
	generr "lab.weave.nl/weave/generator/pkg/errors"
)

var (
	// A private key for context that only this package can access. This is
	// important to prevent collisions between different context uses.
	userCtxKey = &contextKey{"user"}
	schemeName = "Authorization"
)

type contextKey struct {
	name string
}

// GetUser finds the User from the context. REQUIRES Middleware to have run.
func GetUser(ctx context.Context) *models.User {
	raw, _ := ctx.Value(userCtxKey).(*models.User)
	return raw
}

func SetUser(ctx context.Context, user *models.User) context.Context {
	return context.WithValue(ctx, userCtxKey, user)
}

func UserHasScope(ctx context.Context, scope string) bool {
	user := GetUser(ctx)

	// Return false if not logged in.
	if user == nil {
		return false
	}

	// Return false if an empty scope is given.
	if len(scope) == 0 {
		return false
	}

	// Wrap scope name with " to make sure the strings.Contains function
	// doesn't find a partial match.
	scope = fmt.Sprintf("\"%s\"", scope)

	// Return true if the scopes of the user contain the given scope.
	return strings.Contains(string(user.Scopes.RawMessage), scope)
}

func NewBasicAuthMiddleware(db *gorm.DB) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Retrieve credentials
			email, password, ok := r.BasicAuth()
			if !ok {
				next.ServeHTTP(w, r)
				return
			}

			path := ast.Path{ast.PathName("_request"), ast.PathName("headers"), ast.PathName(schemeName)}
			ctx := r.Context()

			// Find user
			var user models.User
			err := db.Where("lower(email) = ?", strings.ToLower(email)).Find(&user).Error
			if err != nil {
				if err == gorm.ErrRecordNotFound {
					sendGraphQLError(ctx, w, path, ErrUnauthorized)
					return
				}
				sendGraphQLError(ctx, w, path, generr.WrapAsInternal(err, fmt.Sprintf("could not retrieve User %s", email)))
				return
			}

			// Check password
			err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
			if err != nil {
				sendGraphQLError(ctx, w, path, ErrUnauthorized)
				return
			}

			// Add User to request context
			ctx = context.WithValue(ctx, userCtxKey, &user)
			r = r.WithContext(ctx)

			// Proceed
			w.Header().Set("Access-Control-Expose-Headers", schemeName)
			next.ServeHTTP(w, r)
		})
	}
}

func AddUserToContext(ctx context.Context, db *gorm.DB, pubKeyFunc jwt.Keyfunc, authHeader string) (context.Context, error) {
	if authHeader == "" {
		return ctx, nil
	}

	// Check if header begins with 'bearer'
	if !strings.HasPrefix(strings.ToLower(authHeader), "bearer ") {
		return ctx, fmt.Errorf("%w: %s header did not have prefix \"bearer\"", ErrUnauthorized, schemeName)
	}

	// Check if header/token is valid
	bearer := strings.Split(authHeader, " ")[1]
	token, err := jwt.Parse(bearer, pubKeyFunc)
	if err != nil {
		return ctx, fmt.Errorf("%w: could not parse jwt token: %v", ErrUnauthorized, err)
	}
	if !token.Valid {
		return ctx, fmt.Errorf("%w: invalid jwt token", ErrUnauthorized)
	}

	// Check claims
	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		return ctx, fmt.Errorf("%w: invalid claims: %v", ErrUnauthorized, err)
	}

	// Retrieve user
	userID := claims["user"]
	var user models.User
	if err := db.First(&user, "id = ?", userID).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			log.Warningf("User that does not exist tried to login with a valid token and userid %v", userID)
		}
		return ctx, generr.WrapAsInternal(err, fmt.Sprintf("could not get User %v", userID))
	}

	// Add User to request context
	return context.WithValue(ctx, userCtxKey, &user), nil
}

const defaultInternalServerError = "{\"errors\":[{\"message\":\"internal server error\"}]}"

func sendGraphQLError(ctx context.Context, w http.ResponseWriter, path ast.Path, err error) {
	// Present the error
	gqlErr := gqlerror.WrapPath(path, err)
	presenter := generr.NewPresenter(&generr.LogrusErrorLogger{}) // FIXME make this logger configurable
	presentedErr := presenter.Present(ctx, gqlErr)
	res := &graphql.Response{
		Errors: gqlerror.List{presentedErr},
	}

	// Make sure http status code is correct
	statusCode := http.StatusUnauthorized
	var isInternalErr generr.WithIsInternal
	if errors.As(err, &isInternalErr) {
		if isInternalErr.IsInternal() {
			statusCode = http.StatusInternalServerError
		}
	}

	// Marshal and return
	jsonRes, marshalErr := json.Marshal(res)
	if marshalErr != nil {
		http.Error(w, defaultInternalServerError, http.StatusInternalServerError)
		return
	}
	http.Error(w, string(jsonRes), statusCode)
}

// Middleware decodes the share session cookie and packs the session into context
func NewJWTAuthMiddleware(db *gorm.DB, pubKeyFunc jwt.Keyfunc) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Get header
			authHeader := r.Header.Get(schemeName)

			ctx, err := AddUserToContext(r.Context(), db, pubKeyFunc, authHeader)
			if err != nil {
				path := ast.Path{ast.PathName("_request"), ast.PathName("headers"), ast.PathName(schemeName)}
				sendGraphQLError(ctx, w, path, err)
				return
			}

			r = r.WithContext(ctx)

			// Proceed
			w.Header().Set("Access-Control-Expose-Headers", schemeName)
			next.ServeHTTP(w, r)
		})
	}
}

var ErrUnauthorized = generr.NewGraphQLError("unauthorized", false, "UNAUTHORIZED")

// NewIstioAuthMiddleware creates middleware for JWT's already checked by Istio
func NewIstioAuthMiddleware(db *gorm.DB) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			path := ast.Path{ast.PathName("_request"), ast.PathName("headers"), ast.PathName("claims")}
			// We expect istio to return the claims in header JWT
			jwtBase64Claims := r.Header.Get("claims")
			// We are only interested in the subject
			claims := struct {
				Subject string `json:"sub"`
			}{}
			ctx := r.Context()
			claimsJSON, err := base64.RawURLEncoding.DecodeString(jwtBase64Claims)
			if err != nil {
				sendGraphQLError(ctx, w, path, fmt.Errorf("%w: can't parse claims from base 64: %v", ErrUnauthorized, err))
				return
			}

			err = json.Unmarshal(claimsJSON, &claims)
			if err != nil {
				sendGraphQLError(ctx, w, path, fmt.Errorf("%w: can't unmarshal claims: %v", ErrUnauthorized, err))
				return
			}
			// Find subject
			var user models.User
			if err := db.First(&user, "id = ?", claims.Subject).Error; err != nil {
				sendGraphQLError(ctx, w, path, generr.WrapAsInternal(err, "getting claims user"))
				return
			}
			// Add user to request context
			r = r.WithContext(context.WithValue(r.Context(), userCtxKey, &user))

			next.ServeHTTP(w, r)
		})
	}
}
